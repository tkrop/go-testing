package mock

import (
	"strconv"
	"strings"
	"text/template"
)

var (
	ImportReflect = &Import{
		Alias: "reflect",
		Path:  "reflect",
	}
	ImportGomock = &Import{
		Alias: "gomock",
		Path:  "github.com/golang/mock/gomock",
	}
)

func NewTemplate() *template.Template {
	return template.Must(template.New("file").Funcs(funcs).Parse(fileTemplate))
}

func NewFiles(mocks []*Mock) []*File {
	builders := []*FileBuilder{}

	bmap := map[Type]*FileBuilder{}
	for _, mock := range mocks {
		target := mock.Target
		target.Name = "" // file has no target name!
		if builder, ok := bmap[target]; !ok {
			builder := NewFileBuilder(target)
			builders = append(builders, builder)
			bmap[target] = builder
		} else {
			builder.AddMocks(mock)
		}
	}

	files := []*File{}
	for _, builder := range builders {
		file := builder.AddImports(ImportReflect, ImportGomock).Build()
		files = append(files, file)
	}

	return files
}

func importArgs(imports []*Import) string {
	builder := strings.Builder{}
	for _, imprt := range imports {
		builder.WriteRune('\t')
		if imprt.Alias != "" {
			builder.WriteString(imprt.Alias)
			builder.WriteRune(' ')
		}
		builder.WriteRune('"')
		builder.WriteString(imprt.Path)
		builder.WriteString("\"\n")
	}
	return builder.String()
}

func paramArgs(params []Param) string {
	builder := strings.Builder{}
	mindex := len(params) - 1
	for index, param := range params {
		if index > 0 {
			builder.WriteString(", ")
		}
		builder.WriteString(param.Name)
		if index == mindex || params[index+1].Type != param.Type {
			builder.WriteRune(' ')
			builder.WriteString(param.Type)
		}
	}
	return builder.String()
}

func resultArgs(params []Param) string {
	builder := strings.Builder{}
	if len(params) > 1 {
		builder.WriteRune('(')
	}
	for index, result := range params {
		if index > 0 {
			builder.WriteString(", ")
		}
		builder.WriteString(result.Type)
	}
	if len(params) > 1 {
		builder.WriteRune(')')
	}
	return builder.String()
}

func callArgs(params []Param) string {
	builder := strings.Builder{}
	for index, param := range params {
		if index > 0 {
			builder.WriteString(", ")
		}
		if param.Name != "" {
			builder.WriteString(param.Name)
		} else {
			builder.WriteString("ret")
			builder.WriteString(strconv.Itoa(index))
		}
	}
	return builder.String()
}

func convertArgs(params []Param) string {
	builder := strings.Builder{}
	for index, param := range params {
		istr := strconv.Itoa(index)
		if index > 1 {
			builder.WriteString("\n\t")
		}
		if param.Name != "" {
			builder.WriteString(param.Name)
		} else {
			builder.WriteString("ret")
			builder.WriteString(istr)
		}
		builder.WriteString(", _ := ret[")
		builder.WriteString(istr)
		builder.WriteString("].(")
		builder.WriteString(param.Type)
		builder.WriteString(")")
	}
	return builder.String()
}

// This list comes from the golint codebase. Golint will complain about any of
// these being mixed-case, like "Id" instead of "ID".
var golintInitialisms = []string{
	"ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", "HTTPS", "ID", "IP", "JSON", "LHS",
	"QPS", "RAM", "RHS", "RPC", "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI",
	"URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS",
}

var funcs = template.FuncMap{
	"ImportsList": importArgs,
	"ParamArgs":   paramArgs,
	"ResultArgs":  resultArgs,
	"CallArgs":    callArgs,
	"ConvertArgs": convertArgs,
	// "SyncPkgQualifier": func(imports []*registry.Package) string {
	// 	for _, imprt := range imports {
	// 		if imprt.Path() == "sync" {
	// 			return imprt.Qualifier()
	// 		}
	// 	}

	// 	return "sync"
	// },
	"Exported": func(s string) string {
		if s == "" {
			return ""
		}
		for _, initialism := range golintInitialisms {
			if strings.ToUpper(s) == initialism {
				return initialism
			}
		}
		return strings.ToUpper(s[0:1]) + s[1:]
	},
}

var fileTemplate = `// Code generated by mock; DO NOT EDIT.
package {{.Target.Package}}

import (
{{.Imports | ImportsList}}
)

{{- range $index, $mock := .Mocks}}
// {{$mock.Target.Name}} is a mock of {{$mock.Source.Name}} interface.
type {{$mock.Target.Name}} struct {
	ctrl     *gomock.Controller
	recorder *{{$mock.Target.Name}}Recorder
}

// {{$mock.Target.Name}}Recorder is the mock recorder for {{$mock.Target.Name}}.
type {{$mock.Target.Name}}Recorder struct {
	mock *{{$mock.Target.Name}}
}

// New{{$mock.Target.Name}} creates a new mock instance.
func New{{$mock.Target.Name}}(ctrl *gomock.Controller) *{{$mock.Target.Name}} {
	mock := &{{$mock.Target.Name}}{ctrl: ctrl}
	mock.recorder = &{{$mock.Target.Name}}Recorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *{{$mock.Target.Name}}) EXPECT() *{{$mock.Target.Name}}Recorder {
	return m.recorder
}

{{range $index, $method := .Methods}}
// {{$method.Name}} is the mock method to capture a coresponding call.
func (m *{{$mock.Target.Name}}) {{$method.Name}}(
	{{- if $method.Params -}} {{$method.Params | ParamArgs}} {{- end -}}
) {{- if $method.Results}} {{$method.Results | ResultArgs }} {{- end }} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "{{$method.Name}}"
		{{- if $method.Params}}, {{$method.Params | CallArgs}} {{- end}})

	{{if $method.Results -}}{{$method.Results | ConvertArgs}}{{- end}}

	return {{- if $method.Results}} {{$method.Results | CallArgs}} {{- end}}
}

// {{$method.Name}} is the recorder method to indicates an expected call.
func (mr *{{$mock.Target.Name}}Recorder) {{$method.Name}}(
	{{- if $method.Params -}} {{$method.Params | ParamArgs}} {{- end -}}
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "{{$method.Name}}",
		reflect.TypeOf((*{{$mock.Target.Name}})(nil).{{$method.Name}})
		{{- if $method.Params}}, {{$method.Params | CallArgs}} {{- end}})
}
{{- end}}
{{- end}}
`
